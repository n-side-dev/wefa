import { type Meta, type StoryObj } from '@storybook/vue3-vite'
import { expect, within, waitFor, userEvent } from 'storybook/test'
import { ref } from 'vue'
import ApiClient from '@/network/apiClient'
import AxiosMockAdapter from 'axios-mock-adapter'

import NetworkButton from './NetworkButton.vue'

// Extend the component props with custom story args
interface StoryArgs {
  apiMockResponseCode?: number
}

/**
 * Creates a real ApiInterface using ApiClient with AxiosMockAdapter for testing purposes
 * @param responseCode - The HTTP response code to mock (200 for success, 4xx/5xx for error)
 * @param responseData - The response data to return on success
 * @param delayMs - The delay in milliseconds to simulate network latency
 * @returns A real ApiInterface implementation for testing
 */
function createApiInterface(
  responseCode: number = 200,
  responseData: unknown = { success: true },
  delayMs: number = 1000
): ApiInterface {
  const apiClient = new ApiClient('http://localhost')
  const axiosMock = new AxiosMockAdapter(apiClient.axiosInstance)
  const url = ref('/test-endpoint')
  const postData = ref({ key: 'test-value' })

  // Configure mock response based on response code
  if (responseCode >= 200 && responseCode < 300) {
    axiosMock.onPost(url.value).withDelayInMs(delayMs).reply(responseCode, responseData)
  } else {
    axiosMock.onPost(url.value).withDelayInMs(delayMs).reply(responseCode, {
      message: 'Network error',
      status: responseCode,
    })
  }

  return apiClient.post(url, postData)
}

/**
 * Helper function to wait for button state changes
 * @param canvas - The testing canvas from Storybook's within function
 * @param expectedText - The expected button text
 */
async function waitForButtonState(canvas: ReturnType<typeof within>, expectedText: string) {
  await waitFor(async () => {
    const button = canvas.getByRole('button')
    await expect(button).toHaveTextContent(expectedText)
  })
}

/**
 * Helper function to test button click interaction
 * @param canvas - The testing canvas from Storybook's within function
 */
async function testButtonClick(canvas: ReturnType<typeof within>) {
  const button = canvas.getByRole('button')
  await userEvent.click(button)
}

const meta: Meta<typeof NetworkButton & StoryArgs> = {
  title: 'Components/NetworkButton',
  component: NetworkButton,
  parameters: {
    layout: 'centered',
  },
  args: {
    relaunchableOnError: false,
    relaunchableOnSuccess: false,
  },
  argTypes: {
    relaunchableOnError: {
      control: 'boolean',
      description: 'Whether the button can be clicked again after an error occurs',
    },
    relaunchableOnSuccess: {
      control: 'boolean',
      description: 'Whether the button can be clicked again after a successful response',
    },
    query: {
      control: false,
      description: 'The API interface object that manages the network request state',
    },
    defaultButton: {
      control: 'object',
      description: 'Configuration for the default/initial button state',
    },
    successButton: {
      control: 'object',
      description: 'Configuration for the success button state',
    },
    errorButton: {
      control: 'object',
      description: 'Configuration for the error button state',
    },
    loadingButton: {
      control: 'object',
      description: 'Configuration for the loading button state',
    },
  },
}

export default meta
type Story = StoryObj<typeof meta>

export const Default: Story = {
  render: (args) => ({
    components: { NetworkButton },
    setup() {
      const query = createApiInterface((args as typeof args & StoryArgs).apiMockResponseCode)
      return { args, query }
    },
    template: `
      <NetworkButton v-bind="args" :query="query"/>
    `,
  }),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)

    // Initially should show default state
    await waitForButtonState(canvas, 'Submit')

    // Button should be enabled and clickable
    const button = canvas.getByRole('button')
    await expect(button).toBeEnabled()

    // Test button click triggers loading state
    await testButtonClick(canvas)
    await waitForButtonState(canvas, 'Loading...')

    // Button should be disabled during loading
    await expect(button).toBeDisabled()

    // Wait for success state
    await waitFor(
      async () => {
        await waitForButtonState(canvas, 'Success')
      },
      { timeout: 2000 }
    )

    // Button should be disabled in success state (not relaunchable)
    await expect(button).toBeDisabled()
  },
}

export const WithCustomLabels: Story = {
  args: {
    defaultButton: {
      text: 'Save Changes',
      icon: 'pi pi-save',
    },
    successButton: {
      text: 'Saved!',
      icon: 'pi pi-check-circle',
    },
    errorButton: {
      text: 'Save Failed',
      icon: 'pi pi-times-circle',
    },
    loadingButton: {
      text: 'Saving...',
    },
  },
  render: (args) => ({
    components: { NetworkButton },
    setup() {
      const query = createApiInterface((args as typeof args & StoryArgs).apiMockResponseCode)
      return { args, query }
    },
    template: `
      <NetworkButton v-bind="args" :query="query"/>
    `,
  }),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)

    // Should show custom default text
    await waitForButtonState(canvas, 'Save Changes')

    // Test the flow with custom labels
    await testButtonClick(canvas)
    await waitForButtonState(canvas, 'Saving...')

    await waitFor(
      async () => {
        await waitForButtonState(canvas, 'Saved!')
      },
      { timeout: 2000 }
    )
  },
}

export const RelaunchableOnSuccess: Story = {
  args: {
    relaunchableOnSuccess: true,
    successButton: {
      text: 'Success - Click Again',
      icon: 'pi pi-refresh',
    },
  },
  render: (args) => ({
    components: { NetworkButton },
    setup() {
      const query = createApiInterface((args as typeof args & StoryArgs).apiMockResponseCode)
      return { args, query }
    },
    template: `
      <NetworkButton v-bind="args" :query="query"/>
    `,
  }),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)

    // Complete initial flow
    await testButtonClick(canvas)
    await waitForButtonState(canvas, 'Loading...')

    await waitFor(
      async () => {
        await waitForButtonState(canvas, 'Success - Click Again')
      },
      { timeout: 2000 }
    )

    // Button should be enabled for relaunch
    const button = canvas.getByRole('button')
    await expect(button).toBeEnabled()

    // Test relaunch functionality
    await testButtonClick(canvas)
    await waitForButtonState(canvas, 'Loading...')
  },
}

export const ErrorState: Story = {
  args: {
    relaunchableOnError: false,
  },
  render: (args) => ({
    components: { NetworkButton },
    setup() {
      const query = createApiInterface(500) // Use 500 for error state
      return { args, query }
    },
    template: `
      <NetworkButton v-bind="args" :query="query"/>
    `,
  }),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)

    // Trigger error flow
    await testButtonClick(canvas)
    await waitForButtonState(canvas, 'Loading...')

    await waitFor(
      async () => {
        await waitForButtonState(canvas, 'Error')
      },
      { timeout: 2000 }
    )

    // Button should be disabled in error state (not relaunchable)
    const button = canvas.getByRole('button')
    await expect(button).toBeDisabled()
  },
}

export const RelaunchableOnError: Story = {
  args: {
    relaunchableOnError: true,
  },
  render: (args) => ({
    components: { NetworkButton },
    setup() {
      const query = createApiInterface(500) // Use 500 for error state
      return { args, query }
    },
    template: `
      <NetworkButton v-bind="args" :query="query"/>
    `,
  }),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)

    // Trigger error flow
    await testButtonClick(canvas)
    await waitForButtonState(canvas, 'Loading...')

    await waitFor(
      async () => {
        await waitForButtonState(canvas, 'Retry')
      },
      { timeout: 2000 }
    )

    // Button should be enabled for retry
    const button = canvas.getByRole('button')
    await expect(button).toBeEnabled()

    // Test retry functionality
    await testButtonClick(canvas)
    await waitForButtonState(canvas, 'Loading...')
  },
}

export const LoadingState: Story = {
  args: {},
  render: (args) => ({
    components: { NetworkButton },
    setup() {
      const query = createApiInterface(
        (args as typeof args & StoryArgs).apiMockResponseCode || 200,
        { success: true },
        10000
      ) // 10 second delay
      // Trigger the action immediately to show loading state
      query.action()
      return { args, query }
    },
    template: `
      <NetworkButton v-bind="args" :query="query"/>
    `,
  }),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)

    // Should immediately show loading state
    await waitForButtonState(canvas, 'Loading...')

    // Button should be disabled during loading
    const button = canvas.getByRole('button')
    await expect(button).toBeDisabled()
  },
}

export const WithCustomStyling: Story = {
  args: {
    defaultButton: {
      text: 'Custom Button',
      class: 'p-button-lg p-button-rounded',
    },
    successButton: {
      text: 'Custom Success',
      class: 'p-button-lg p-button-rounded',
    },
  },
  render: (args) => ({
    components: { NetworkButton },
    setup() {
      const query = createApiInterface((args as typeof args & StoryArgs).apiMockResponseCode)
      return { args, query }
    },
    template: `
      <NetworkButton v-bind="args" :query="query"/>
    `,
  }),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)

    // Should show custom styled button
    await waitForButtonState(canvas, 'Custom Button')

    const button = canvas.getByRole('button')
    await expect(button).toHaveClass('p-button-lg')
    await expect(button).toHaveClass('p-button-rounded')
  },
}
